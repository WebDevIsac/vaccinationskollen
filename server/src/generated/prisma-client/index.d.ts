// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  child: (where?: ChildWhereInput) => Promise<boolean>;
  childVaccination: (where?: ChildVaccinationWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userVaccination: (where?: UserVaccinationWhereInput) => Promise<boolean>;
  vaccination: (where?: VaccinationWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  child: (where: ChildWhereUniqueInput) => ChildNullablePromise;
  children: (args?: {
    where?: ChildWhereInput;
    orderBy?: ChildOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Child>;
  childrenConnection: (args?: {
    where?: ChildWhereInput;
    orderBy?: ChildOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChildConnectionPromise;
  childVaccination: (
    where: ChildVaccinationWhereUniqueInput
  ) => ChildVaccinationNullablePromise;
  childVaccinations: (args?: {
    where?: ChildVaccinationWhereInput;
    orderBy?: ChildVaccinationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ChildVaccination>;
  childVaccinationsConnection: (args?: {
    where?: ChildVaccinationWhereInput;
    orderBy?: ChildVaccinationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChildVaccinationConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userVaccination: (
    where: UserVaccinationWhereUniqueInput
  ) => UserVaccinationNullablePromise;
  userVaccinations: (args?: {
    where?: UserVaccinationWhereInput;
    orderBy?: UserVaccinationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserVaccination>;
  userVaccinationsConnection: (args?: {
    where?: UserVaccinationWhereInput;
    orderBy?: UserVaccinationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserVaccinationConnectionPromise;
  vaccination: (
    where: VaccinationWhereUniqueInput
  ) => VaccinationNullablePromise;
  vaccinations: (args?: {
    where?: VaccinationWhereInput;
    orderBy?: VaccinationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Vaccination>;
  vaccinationsConnection: (args?: {
    where?: VaccinationWhereInput;
    orderBy?: VaccinationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VaccinationConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createChild: (data: ChildCreateInput) => ChildPromise;
  updateChild: (args: {
    data: ChildUpdateInput;
    where: ChildWhereUniqueInput;
  }) => ChildPromise;
  updateManyChildren: (args: {
    data: ChildUpdateManyMutationInput;
    where?: ChildWhereInput;
  }) => BatchPayloadPromise;
  upsertChild: (args: {
    where: ChildWhereUniqueInput;
    create: ChildCreateInput;
    update: ChildUpdateInput;
  }) => ChildPromise;
  deleteChild: (where: ChildWhereUniqueInput) => ChildPromise;
  deleteManyChildren: (where?: ChildWhereInput) => BatchPayloadPromise;
  createChildVaccination: (
    data: ChildVaccinationCreateInput
  ) => ChildVaccinationPromise;
  updateChildVaccination: (args: {
    data: ChildVaccinationUpdateInput;
    where: ChildVaccinationWhereUniqueInput;
  }) => ChildVaccinationPromise;
  updateManyChildVaccinations: (args: {
    data: ChildVaccinationUpdateManyMutationInput;
    where?: ChildVaccinationWhereInput;
  }) => BatchPayloadPromise;
  upsertChildVaccination: (args: {
    where: ChildVaccinationWhereUniqueInput;
    create: ChildVaccinationCreateInput;
    update: ChildVaccinationUpdateInput;
  }) => ChildVaccinationPromise;
  deleteChildVaccination: (
    where: ChildVaccinationWhereUniqueInput
  ) => ChildVaccinationPromise;
  deleteManyChildVaccinations: (
    where?: ChildVaccinationWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserVaccination: (
    data: UserVaccinationCreateInput
  ) => UserVaccinationPromise;
  updateUserVaccination: (args: {
    data: UserVaccinationUpdateInput;
    where: UserVaccinationWhereUniqueInput;
  }) => UserVaccinationPromise;
  updateManyUserVaccinations: (args: {
    data: UserVaccinationUpdateManyMutationInput;
    where?: UserVaccinationWhereInput;
  }) => BatchPayloadPromise;
  upsertUserVaccination: (args: {
    where: UserVaccinationWhereUniqueInput;
    create: UserVaccinationCreateInput;
    update: UserVaccinationUpdateInput;
  }) => UserVaccinationPromise;
  deleteUserVaccination: (
    where: UserVaccinationWhereUniqueInput
  ) => UserVaccinationPromise;
  deleteManyUserVaccinations: (
    where?: UserVaccinationWhereInput
  ) => BatchPayloadPromise;
  createVaccination: (data: VaccinationCreateInput) => VaccinationPromise;
  updateVaccination: (args: {
    data: VaccinationUpdateInput;
    where: VaccinationWhereUniqueInput;
  }) => VaccinationPromise;
  updateManyVaccinations: (args: {
    data: VaccinationUpdateManyMutationInput;
    where?: VaccinationWhereInput;
  }) => BatchPayloadPromise;
  upsertVaccination: (args: {
    where: VaccinationWhereUniqueInput;
    create: VaccinationCreateInput;
    update: VaccinationUpdateInput;
  }) => VaccinationPromise;
  deleteVaccination: (where: VaccinationWhereUniqueInput) => VaccinationPromise;
  deleteManyVaccinations: (
    where?: VaccinationWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  child: (
    where?: ChildSubscriptionWhereInput
  ) => ChildSubscriptionPayloadSubscription;
  childVaccination: (
    where?: ChildVaccinationSubscriptionWhereInput
  ) => ChildVaccinationSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userVaccination: (
    where?: UserVaccinationSubscriptionWhereInput
  ) => UserVaccinationSubscriptionPayloadSubscription;
  vaccination: (
    where?: VaccinationSubscriptionWhereInput
  ) => VaccinationSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type UserVaccinationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "takenAt_ASC"
  | "takenAt_DESC"
  | "untilNext_ASC"
  | "untilNext_DESC"
  | "protectDuration_ASC"
  | "protectDuration_DESC";

export type ChildOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "born_ASC"
  | "born_DESC";

export type ChildVaccinationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "takenAt_ASC"
  | "takenAt_DESC"
  | "untilNext_ASC"
  | "untilNext_DESC"
  | "protectDuration_ASC"
  | "protectDuration_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC";

export type VaccinationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "dose_ASC"
  | "dose_DESC"
  | "url_ASC"
  | "url_DESC"
  | "untilNext_ASC"
  | "untilNext_DESC"
  | "protectDuration_ASC"
  | "protectDuration_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ChildWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserVaccinationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  type?: Maybe<VaccinationWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  takenAt?: Maybe<DateTimeInput>;
  takenAt_not?: Maybe<DateTimeInput>;
  takenAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  takenAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  takenAt_lt?: Maybe<DateTimeInput>;
  takenAt_lte?: Maybe<DateTimeInput>;
  takenAt_gt?: Maybe<DateTimeInput>;
  takenAt_gte?: Maybe<DateTimeInput>;
  untilNext?: Maybe<String>;
  untilNext_not?: Maybe<String>;
  untilNext_in?: Maybe<String[] | String>;
  untilNext_not_in?: Maybe<String[] | String>;
  untilNext_lt?: Maybe<String>;
  untilNext_lte?: Maybe<String>;
  untilNext_gt?: Maybe<String>;
  untilNext_gte?: Maybe<String>;
  untilNext_contains?: Maybe<String>;
  untilNext_not_contains?: Maybe<String>;
  untilNext_starts_with?: Maybe<String>;
  untilNext_not_starts_with?: Maybe<String>;
  untilNext_ends_with?: Maybe<String>;
  untilNext_not_ends_with?: Maybe<String>;
  protectDuration?: Maybe<String>;
  protectDuration_not?: Maybe<String>;
  protectDuration_in?: Maybe<String[] | String>;
  protectDuration_not_in?: Maybe<String[] | String>;
  protectDuration_lt?: Maybe<String>;
  protectDuration_lte?: Maybe<String>;
  protectDuration_gt?: Maybe<String>;
  protectDuration_gte?: Maybe<String>;
  protectDuration_contains?: Maybe<String>;
  protectDuration_not_contains?: Maybe<String>;
  protectDuration_starts_with?: Maybe<String>;
  protectDuration_not_starts_with?: Maybe<String>;
  protectDuration_ends_with?: Maybe<String>;
  protectDuration_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserVaccinationWhereInput[] | UserVaccinationWhereInput>;
  OR?: Maybe<UserVaccinationWhereInput[] | UserVaccinationWhereInput>;
  NOT?: Maybe<UserVaccinationWhereInput[] | UserVaccinationWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  vaccinations_every?: Maybe<UserVaccinationWhereInput>;
  vaccinations_some?: Maybe<UserVaccinationWhereInput>;
  vaccinations_none?: Maybe<UserVaccinationWhereInput>;
  children_every?: Maybe<ChildWhereInput>;
  children_some?: Maybe<ChildWhereInput>;
  children_none?: Maybe<ChildWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ChildWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  parent?: Maybe<UserWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  born?: Maybe<DateTimeInput>;
  born_not?: Maybe<DateTimeInput>;
  born_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  born_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  born_lt?: Maybe<DateTimeInput>;
  born_lte?: Maybe<DateTimeInput>;
  born_gt?: Maybe<DateTimeInput>;
  born_gte?: Maybe<DateTimeInput>;
  vaccinations_every?: Maybe<ChildVaccinationWhereInput>;
  vaccinations_some?: Maybe<ChildVaccinationWhereInput>;
  vaccinations_none?: Maybe<ChildVaccinationWhereInput>;
  AND?: Maybe<ChildWhereInput[] | ChildWhereInput>;
  OR?: Maybe<ChildWhereInput[] | ChildWhereInput>;
  NOT?: Maybe<ChildWhereInput[] | ChildWhereInput>;
}

export interface ChildVaccinationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  child?: Maybe<ChildWhereInput>;
  type?: Maybe<VaccinationWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  takenAt?: Maybe<DateTimeInput>;
  takenAt_not?: Maybe<DateTimeInput>;
  takenAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  takenAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  takenAt_lt?: Maybe<DateTimeInput>;
  takenAt_lte?: Maybe<DateTimeInput>;
  takenAt_gt?: Maybe<DateTimeInput>;
  takenAt_gte?: Maybe<DateTimeInput>;
  untilNext?: Maybe<String>;
  untilNext_not?: Maybe<String>;
  untilNext_in?: Maybe<String[] | String>;
  untilNext_not_in?: Maybe<String[] | String>;
  untilNext_lt?: Maybe<String>;
  untilNext_lte?: Maybe<String>;
  untilNext_gt?: Maybe<String>;
  untilNext_gte?: Maybe<String>;
  untilNext_contains?: Maybe<String>;
  untilNext_not_contains?: Maybe<String>;
  untilNext_starts_with?: Maybe<String>;
  untilNext_not_starts_with?: Maybe<String>;
  untilNext_ends_with?: Maybe<String>;
  untilNext_not_ends_with?: Maybe<String>;
  protectDuration?: Maybe<String>;
  protectDuration_not?: Maybe<String>;
  protectDuration_in?: Maybe<String[] | String>;
  protectDuration_not_in?: Maybe<String[] | String>;
  protectDuration_lt?: Maybe<String>;
  protectDuration_lte?: Maybe<String>;
  protectDuration_gt?: Maybe<String>;
  protectDuration_gte?: Maybe<String>;
  protectDuration_contains?: Maybe<String>;
  protectDuration_not_contains?: Maybe<String>;
  protectDuration_starts_with?: Maybe<String>;
  protectDuration_not_starts_with?: Maybe<String>;
  protectDuration_ends_with?: Maybe<String>;
  protectDuration_not_ends_with?: Maybe<String>;
  AND?: Maybe<ChildVaccinationWhereInput[] | ChildVaccinationWhereInput>;
  OR?: Maybe<ChildVaccinationWhereInput[] | ChildVaccinationWhereInput>;
  NOT?: Maybe<ChildVaccinationWhereInput[] | ChildVaccinationWhereInput>;
}

export interface VaccinationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  dose?: Maybe<Int>;
  dose_not?: Maybe<Int>;
  dose_in?: Maybe<Int[] | Int>;
  dose_not_in?: Maybe<Int[] | Int>;
  dose_lt?: Maybe<Int>;
  dose_lte?: Maybe<Int>;
  dose_gt?: Maybe<Int>;
  dose_gte?: Maybe<Int>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  untilNext?: Maybe<String>;
  untilNext_not?: Maybe<String>;
  untilNext_in?: Maybe<String[] | String>;
  untilNext_not_in?: Maybe<String[] | String>;
  untilNext_lt?: Maybe<String>;
  untilNext_lte?: Maybe<String>;
  untilNext_gt?: Maybe<String>;
  untilNext_gte?: Maybe<String>;
  untilNext_contains?: Maybe<String>;
  untilNext_not_contains?: Maybe<String>;
  untilNext_starts_with?: Maybe<String>;
  untilNext_not_starts_with?: Maybe<String>;
  untilNext_ends_with?: Maybe<String>;
  untilNext_not_ends_with?: Maybe<String>;
  protectDuration?: Maybe<String>;
  protectDuration_not?: Maybe<String>;
  protectDuration_in?: Maybe<String[] | String>;
  protectDuration_not_in?: Maybe<String[] | String>;
  protectDuration_lt?: Maybe<String>;
  protectDuration_lte?: Maybe<String>;
  protectDuration_gt?: Maybe<String>;
  protectDuration_gte?: Maybe<String>;
  protectDuration_contains?: Maybe<String>;
  protectDuration_not_contains?: Maybe<String>;
  protectDuration_starts_with?: Maybe<String>;
  protectDuration_not_starts_with?: Maybe<String>;
  protectDuration_ends_with?: Maybe<String>;
  protectDuration_not_ends_with?: Maybe<String>;
  AND?: Maybe<VaccinationWhereInput[] | VaccinationWhereInput>;
  OR?: Maybe<VaccinationWhereInput[] | VaccinationWhereInput>;
  NOT?: Maybe<VaccinationWhereInput[] | VaccinationWhereInput>;
}

export type ChildVaccinationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export type UserVaccinationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type VaccinationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ChildCreateInput {
  id?: Maybe<ID_Input>;
  parent: UserCreateOneWithoutChildrenInput;
  name: String;
  born: DateTimeInput;
  vaccinations?: Maybe<ChildVaccinationCreateManyWithoutChildInput>;
}

export interface UserCreateOneWithoutChildrenInput {
  create?: Maybe<UserCreateWithoutChildrenInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutChildrenInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  vaccinations?: Maybe<UserVaccinationCreateManyWithoutUserInput>;
}

export interface UserVaccinationCreateManyWithoutUserInput {
  create?: Maybe<
    | UserVaccinationCreateWithoutUserInput[]
    | UserVaccinationCreateWithoutUserInput
  >;
  connect?: Maybe<
    UserVaccinationWhereUniqueInput[] | UserVaccinationWhereUniqueInput
  >;
}

export interface UserVaccinationCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  type: VaccinationCreateOneInput;
  takenAt?: Maybe<DateTimeInput>;
  untilNext?: Maybe<String>;
  protectDuration?: Maybe<String>;
}

export interface VaccinationCreateOneInput {
  create?: Maybe<VaccinationCreateInput>;
  connect?: Maybe<VaccinationWhereUniqueInput>;
}

export interface VaccinationCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  dose?: Maybe<Int>;
  url: String;
  untilNext?: Maybe<String>;
  protectDuration?: Maybe<String>;
}

export interface ChildVaccinationCreateManyWithoutChildInput {
  create?: Maybe<
    | ChildVaccinationCreateWithoutChildInput[]
    | ChildVaccinationCreateWithoutChildInput
  >;
  connect?: Maybe<
    ChildVaccinationWhereUniqueInput[] | ChildVaccinationWhereUniqueInput
  >;
}

export interface ChildVaccinationCreateWithoutChildInput {
  id?: Maybe<ID_Input>;
  type: VaccinationCreateOneInput;
  takenAt: DateTimeInput;
  untilNext?: Maybe<String>;
  protectDuration?: Maybe<String>;
}

export interface ChildUpdateInput {
  parent?: Maybe<UserUpdateOneRequiredWithoutChildrenInput>;
  name?: Maybe<String>;
  born?: Maybe<DateTimeInput>;
  vaccinations?: Maybe<ChildVaccinationUpdateManyWithoutChildInput>;
}

export interface UserUpdateOneRequiredWithoutChildrenInput {
  create?: Maybe<UserCreateWithoutChildrenInput>;
  update?: Maybe<UserUpdateWithoutChildrenDataInput>;
  upsert?: Maybe<UserUpsertWithoutChildrenInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutChildrenDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  vaccinations?: Maybe<UserVaccinationUpdateManyWithoutUserInput>;
}

export interface UserVaccinationUpdateManyWithoutUserInput {
  create?: Maybe<
    | UserVaccinationCreateWithoutUserInput[]
    | UserVaccinationCreateWithoutUserInput
  >;
  delete?: Maybe<
    UserVaccinationWhereUniqueInput[] | UserVaccinationWhereUniqueInput
  >;
  connect?: Maybe<
    UserVaccinationWhereUniqueInput[] | UserVaccinationWhereUniqueInput
  >;
  set?: Maybe<
    UserVaccinationWhereUniqueInput[] | UserVaccinationWhereUniqueInput
  >;
  disconnect?: Maybe<
    UserVaccinationWhereUniqueInput[] | UserVaccinationWhereUniqueInput
  >;
  update?: Maybe<
    | UserVaccinationUpdateWithWhereUniqueWithoutUserInput[]
    | UserVaccinationUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | UserVaccinationUpsertWithWhereUniqueWithoutUserInput[]
    | UserVaccinationUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    UserVaccinationScalarWhereInput[] | UserVaccinationScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserVaccinationUpdateManyWithWhereNestedInput[]
    | UserVaccinationUpdateManyWithWhereNestedInput
  >;
}

export interface UserVaccinationUpdateWithWhereUniqueWithoutUserInput {
  where: UserVaccinationWhereUniqueInput;
  data: UserVaccinationUpdateWithoutUserDataInput;
}

export interface UserVaccinationUpdateWithoutUserDataInput {
  type?: Maybe<VaccinationUpdateOneRequiredInput>;
  takenAt?: Maybe<DateTimeInput>;
  untilNext?: Maybe<String>;
  protectDuration?: Maybe<String>;
}

export interface VaccinationUpdateOneRequiredInput {
  create?: Maybe<VaccinationCreateInput>;
  update?: Maybe<VaccinationUpdateDataInput>;
  upsert?: Maybe<VaccinationUpsertNestedInput>;
  connect?: Maybe<VaccinationWhereUniqueInput>;
}

export interface VaccinationUpdateDataInput {
  name?: Maybe<String>;
  dose?: Maybe<Int>;
  url?: Maybe<String>;
  untilNext?: Maybe<String>;
  protectDuration?: Maybe<String>;
}

export interface VaccinationUpsertNestedInput {
  update: VaccinationUpdateDataInput;
  create: VaccinationCreateInput;
}

export interface UserVaccinationUpsertWithWhereUniqueWithoutUserInput {
  where: UserVaccinationWhereUniqueInput;
  update: UserVaccinationUpdateWithoutUserDataInput;
  create: UserVaccinationCreateWithoutUserInput;
}

export interface UserVaccinationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  takenAt?: Maybe<DateTimeInput>;
  takenAt_not?: Maybe<DateTimeInput>;
  takenAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  takenAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  takenAt_lt?: Maybe<DateTimeInput>;
  takenAt_lte?: Maybe<DateTimeInput>;
  takenAt_gt?: Maybe<DateTimeInput>;
  takenAt_gte?: Maybe<DateTimeInput>;
  untilNext?: Maybe<String>;
  untilNext_not?: Maybe<String>;
  untilNext_in?: Maybe<String[] | String>;
  untilNext_not_in?: Maybe<String[] | String>;
  untilNext_lt?: Maybe<String>;
  untilNext_lte?: Maybe<String>;
  untilNext_gt?: Maybe<String>;
  untilNext_gte?: Maybe<String>;
  untilNext_contains?: Maybe<String>;
  untilNext_not_contains?: Maybe<String>;
  untilNext_starts_with?: Maybe<String>;
  untilNext_not_starts_with?: Maybe<String>;
  untilNext_ends_with?: Maybe<String>;
  untilNext_not_ends_with?: Maybe<String>;
  protectDuration?: Maybe<String>;
  protectDuration_not?: Maybe<String>;
  protectDuration_in?: Maybe<String[] | String>;
  protectDuration_not_in?: Maybe<String[] | String>;
  protectDuration_lt?: Maybe<String>;
  protectDuration_lte?: Maybe<String>;
  protectDuration_gt?: Maybe<String>;
  protectDuration_gte?: Maybe<String>;
  protectDuration_contains?: Maybe<String>;
  protectDuration_not_contains?: Maybe<String>;
  protectDuration_starts_with?: Maybe<String>;
  protectDuration_not_starts_with?: Maybe<String>;
  protectDuration_ends_with?: Maybe<String>;
  protectDuration_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    UserVaccinationScalarWhereInput[] | UserVaccinationScalarWhereInput
  >;
  OR?: Maybe<
    UserVaccinationScalarWhereInput[] | UserVaccinationScalarWhereInput
  >;
  NOT?: Maybe<
    UserVaccinationScalarWhereInput[] | UserVaccinationScalarWhereInput
  >;
}

export interface UserVaccinationUpdateManyWithWhereNestedInput {
  where: UserVaccinationScalarWhereInput;
  data: UserVaccinationUpdateManyDataInput;
}

export interface UserVaccinationUpdateManyDataInput {
  takenAt?: Maybe<DateTimeInput>;
  untilNext?: Maybe<String>;
  protectDuration?: Maybe<String>;
}

export interface UserUpsertWithoutChildrenInput {
  update: UserUpdateWithoutChildrenDataInput;
  create: UserCreateWithoutChildrenInput;
}

export interface ChildVaccinationUpdateManyWithoutChildInput {
  create?: Maybe<
    | ChildVaccinationCreateWithoutChildInput[]
    | ChildVaccinationCreateWithoutChildInput
  >;
  delete?: Maybe<
    ChildVaccinationWhereUniqueInput[] | ChildVaccinationWhereUniqueInput
  >;
  connect?: Maybe<
    ChildVaccinationWhereUniqueInput[] | ChildVaccinationWhereUniqueInput
  >;
  set?: Maybe<
    ChildVaccinationWhereUniqueInput[] | ChildVaccinationWhereUniqueInput
  >;
  disconnect?: Maybe<
    ChildVaccinationWhereUniqueInput[] | ChildVaccinationWhereUniqueInput
  >;
  update?: Maybe<
    | ChildVaccinationUpdateWithWhereUniqueWithoutChildInput[]
    | ChildVaccinationUpdateWithWhereUniqueWithoutChildInput
  >;
  upsert?: Maybe<
    | ChildVaccinationUpsertWithWhereUniqueWithoutChildInput[]
    | ChildVaccinationUpsertWithWhereUniqueWithoutChildInput
  >;
  deleteMany?: Maybe<
    ChildVaccinationScalarWhereInput[] | ChildVaccinationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ChildVaccinationUpdateManyWithWhereNestedInput[]
    | ChildVaccinationUpdateManyWithWhereNestedInput
  >;
}

export interface ChildVaccinationUpdateWithWhereUniqueWithoutChildInput {
  where: ChildVaccinationWhereUniqueInput;
  data: ChildVaccinationUpdateWithoutChildDataInput;
}

export interface ChildVaccinationUpdateWithoutChildDataInput {
  type?: Maybe<VaccinationUpdateOneRequiredInput>;
  takenAt?: Maybe<DateTimeInput>;
  untilNext?: Maybe<String>;
  protectDuration?: Maybe<String>;
}

export interface ChildVaccinationUpsertWithWhereUniqueWithoutChildInput {
  where: ChildVaccinationWhereUniqueInput;
  update: ChildVaccinationUpdateWithoutChildDataInput;
  create: ChildVaccinationCreateWithoutChildInput;
}

export interface ChildVaccinationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  takenAt?: Maybe<DateTimeInput>;
  takenAt_not?: Maybe<DateTimeInput>;
  takenAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  takenAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  takenAt_lt?: Maybe<DateTimeInput>;
  takenAt_lte?: Maybe<DateTimeInput>;
  takenAt_gt?: Maybe<DateTimeInput>;
  takenAt_gte?: Maybe<DateTimeInput>;
  untilNext?: Maybe<String>;
  untilNext_not?: Maybe<String>;
  untilNext_in?: Maybe<String[] | String>;
  untilNext_not_in?: Maybe<String[] | String>;
  untilNext_lt?: Maybe<String>;
  untilNext_lte?: Maybe<String>;
  untilNext_gt?: Maybe<String>;
  untilNext_gte?: Maybe<String>;
  untilNext_contains?: Maybe<String>;
  untilNext_not_contains?: Maybe<String>;
  untilNext_starts_with?: Maybe<String>;
  untilNext_not_starts_with?: Maybe<String>;
  untilNext_ends_with?: Maybe<String>;
  untilNext_not_ends_with?: Maybe<String>;
  protectDuration?: Maybe<String>;
  protectDuration_not?: Maybe<String>;
  protectDuration_in?: Maybe<String[] | String>;
  protectDuration_not_in?: Maybe<String[] | String>;
  protectDuration_lt?: Maybe<String>;
  protectDuration_lte?: Maybe<String>;
  protectDuration_gt?: Maybe<String>;
  protectDuration_gte?: Maybe<String>;
  protectDuration_contains?: Maybe<String>;
  protectDuration_not_contains?: Maybe<String>;
  protectDuration_starts_with?: Maybe<String>;
  protectDuration_not_starts_with?: Maybe<String>;
  protectDuration_ends_with?: Maybe<String>;
  protectDuration_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    ChildVaccinationScalarWhereInput[] | ChildVaccinationScalarWhereInput
  >;
  OR?: Maybe<
    ChildVaccinationScalarWhereInput[] | ChildVaccinationScalarWhereInput
  >;
  NOT?: Maybe<
    ChildVaccinationScalarWhereInput[] | ChildVaccinationScalarWhereInput
  >;
}

export interface ChildVaccinationUpdateManyWithWhereNestedInput {
  where: ChildVaccinationScalarWhereInput;
  data: ChildVaccinationUpdateManyDataInput;
}

export interface ChildVaccinationUpdateManyDataInput {
  takenAt?: Maybe<DateTimeInput>;
  untilNext?: Maybe<String>;
  protectDuration?: Maybe<String>;
}

export interface ChildUpdateManyMutationInput {
  name?: Maybe<String>;
  born?: Maybe<DateTimeInput>;
}

export interface ChildVaccinationCreateInput {
  id?: Maybe<ID_Input>;
  child: ChildCreateOneWithoutVaccinationsInput;
  type: VaccinationCreateOneInput;
  takenAt: DateTimeInput;
  untilNext?: Maybe<String>;
  protectDuration?: Maybe<String>;
}

export interface ChildCreateOneWithoutVaccinationsInput {
  create?: Maybe<ChildCreateWithoutVaccinationsInput>;
  connect?: Maybe<ChildWhereUniqueInput>;
}

export interface ChildCreateWithoutVaccinationsInput {
  id?: Maybe<ID_Input>;
  parent: UserCreateOneWithoutChildrenInput;
  name: String;
  born: DateTimeInput;
}

export interface ChildVaccinationUpdateInput {
  child?: Maybe<ChildUpdateOneRequiredWithoutVaccinationsInput>;
  type?: Maybe<VaccinationUpdateOneRequiredInput>;
  takenAt?: Maybe<DateTimeInput>;
  untilNext?: Maybe<String>;
  protectDuration?: Maybe<String>;
}

export interface ChildUpdateOneRequiredWithoutVaccinationsInput {
  create?: Maybe<ChildCreateWithoutVaccinationsInput>;
  update?: Maybe<ChildUpdateWithoutVaccinationsDataInput>;
  upsert?: Maybe<ChildUpsertWithoutVaccinationsInput>;
  connect?: Maybe<ChildWhereUniqueInput>;
}

export interface ChildUpdateWithoutVaccinationsDataInput {
  parent?: Maybe<UserUpdateOneRequiredWithoutChildrenInput>;
  name?: Maybe<String>;
  born?: Maybe<DateTimeInput>;
}

export interface ChildUpsertWithoutVaccinationsInput {
  update: ChildUpdateWithoutVaccinationsDataInput;
  create: ChildCreateWithoutVaccinationsInput;
}

export interface ChildVaccinationUpdateManyMutationInput {
  takenAt?: Maybe<DateTimeInput>;
  untilNext?: Maybe<String>;
  protectDuration?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  vaccinations?: Maybe<UserVaccinationCreateManyWithoutUserInput>;
  children?: Maybe<ChildCreateManyWithoutParentInput>;
}

export interface ChildCreateManyWithoutParentInput {
  create?: Maybe<
    ChildCreateWithoutParentInput[] | ChildCreateWithoutParentInput
  >;
  connect?: Maybe<ChildWhereUniqueInput[] | ChildWhereUniqueInput>;
}

export interface ChildCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  name: String;
  born: DateTimeInput;
  vaccinations?: Maybe<ChildVaccinationCreateManyWithoutChildInput>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  vaccinations?: Maybe<UserVaccinationUpdateManyWithoutUserInput>;
  children?: Maybe<ChildUpdateManyWithoutParentInput>;
}

export interface ChildUpdateManyWithoutParentInput {
  create?: Maybe<
    ChildCreateWithoutParentInput[] | ChildCreateWithoutParentInput
  >;
  delete?: Maybe<ChildWhereUniqueInput[] | ChildWhereUniqueInput>;
  connect?: Maybe<ChildWhereUniqueInput[] | ChildWhereUniqueInput>;
  set?: Maybe<ChildWhereUniqueInput[] | ChildWhereUniqueInput>;
  disconnect?: Maybe<ChildWhereUniqueInput[] | ChildWhereUniqueInput>;
  update?: Maybe<
    | ChildUpdateWithWhereUniqueWithoutParentInput[]
    | ChildUpdateWithWhereUniqueWithoutParentInput
  >;
  upsert?: Maybe<
    | ChildUpsertWithWhereUniqueWithoutParentInput[]
    | ChildUpsertWithWhereUniqueWithoutParentInput
  >;
  deleteMany?: Maybe<ChildScalarWhereInput[] | ChildScalarWhereInput>;
  updateMany?: Maybe<
    ChildUpdateManyWithWhereNestedInput[] | ChildUpdateManyWithWhereNestedInput
  >;
}

export interface ChildUpdateWithWhereUniqueWithoutParentInput {
  where: ChildWhereUniqueInput;
  data: ChildUpdateWithoutParentDataInput;
}

export interface ChildUpdateWithoutParentDataInput {
  name?: Maybe<String>;
  born?: Maybe<DateTimeInput>;
  vaccinations?: Maybe<ChildVaccinationUpdateManyWithoutChildInput>;
}

export interface ChildUpsertWithWhereUniqueWithoutParentInput {
  where: ChildWhereUniqueInput;
  update: ChildUpdateWithoutParentDataInput;
  create: ChildCreateWithoutParentInput;
}

export interface ChildScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  born?: Maybe<DateTimeInput>;
  born_not?: Maybe<DateTimeInput>;
  born_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  born_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  born_lt?: Maybe<DateTimeInput>;
  born_lte?: Maybe<DateTimeInput>;
  born_gt?: Maybe<DateTimeInput>;
  born_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ChildScalarWhereInput[] | ChildScalarWhereInput>;
  OR?: Maybe<ChildScalarWhereInput[] | ChildScalarWhereInput>;
  NOT?: Maybe<ChildScalarWhereInput[] | ChildScalarWhereInput>;
}

export interface ChildUpdateManyWithWhereNestedInput {
  where: ChildScalarWhereInput;
  data: ChildUpdateManyDataInput;
}

export interface ChildUpdateManyDataInput {
  name?: Maybe<String>;
  born?: Maybe<DateTimeInput>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface UserVaccinationCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutVaccinationsInput;
  type: VaccinationCreateOneInput;
  takenAt?: Maybe<DateTimeInput>;
  untilNext?: Maybe<String>;
  protectDuration?: Maybe<String>;
}

export interface UserCreateOneWithoutVaccinationsInput {
  create?: Maybe<UserCreateWithoutVaccinationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutVaccinationsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  children?: Maybe<ChildCreateManyWithoutParentInput>;
}

export interface UserVaccinationUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutVaccinationsInput>;
  type?: Maybe<VaccinationUpdateOneRequiredInput>;
  takenAt?: Maybe<DateTimeInput>;
  untilNext?: Maybe<String>;
  protectDuration?: Maybe<String>;
}

export interface UserUpdateOneRequiredWithoutVaccinationsInput {
  create?: Maybe<UserCreateWithoutVaccinationsInput>;
  update?: Maybe<UserUpdateWithoutVaccinationsDataInput>;
  upsert?: Maybe<UserUpsertWithoutVaccinationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutVaccinationsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  children?: Maybe<ChildUpdateManyWithoutParentInput>;
}

export interface UserUpsertWithoutVaccinationsInput {
  update: UserUpdateWithoutVaccinationsDataInput;
  create: UserCreateWithoutVaccinationsInput;
}

export interface UserVaccinationUpdateManyMutationInput {
  takenAt?: Maybe<DateTimeInput>;
  untilNext?: Maybe<String>;
  protectDuration?: Maybe<String>;
}

export interface VaccinationUpdateInput {
  name?: Maybe<String>;
  dose?: Maybe<Int>;
  url?: Maybe<String>;
  untilNext?: Maybe<String>;
  protectDuration?: Maybe<String>;
}

export interface VaccinationUpdateManyMutationInput {
  name?: Maybe<String>;
  dose?: Maybe<Int>;
  url?: Maybe<String>;
  untilNext?: Maybe<String>;
  protectDuration?: Maybe<String>;
}

export interface ChildSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChildWhereInput>;
  AND?: Maybe<ChildSubscriptionWhereInput[] | ChildSubscriptionWhereInput>;
  OR?: Maybe<ChildSubscriptionWhereInput[] | ChildSubscriptionWhereInput>;
  NOT?: Maybe<ChildSubscriptionWhereInput[] | ChildSubscriptionWhereInput>;
}

export interface ChildVaccinationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChildVaccinationWhereInput>;
  AND?: Maybe<
    | ChildVaccinationSubscriptionWhereInput[]
    | ChildVaccinationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ChildVaccinationSubscriptionWhereInput[]
    | ChildVaccinationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ChildVaccinationSubscriptionWhereInput[]
    | ChildVaccinationSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserVaccinationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserVaccinationWhereInput>;
  AND?: Maybe<
    | UserVaccinationSubscriptionWhereInput[]
    | UserVaccinationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserVaccinationSubscriptionWhereInput[]
    | UserVaccinationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserVaccinationSubscriptionWhereInput[]
    | UserVaccinationSubscriptionWhereInput
  >;
}

export interface VaccinationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VaccinationWhereInput>;
  AND?: Maybe<
    VaccinationSubscriptionWhereInput[] | VaccinationSubscriptionWhereInput
  >;
  OR?: Maybe<
    VaccinationSubscriptionWhereInput[] | VaccinationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    VaccinationSubscriptionWhereInput[] | VaccinationSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Child {
  id: ID_Output;
  name: String;
  born: DateTimeOutput;
}

export interface ChildPromise extends Promise<Child>, Fragmentable {
  id: () => Promise<ID_Output>;
  parent: <T = UserPromise>() => T;
  name: () => Promise<String>;
  born: () => Promise<DateTimeOutput>;
  vaccinations: <T = FragmentableArray<ChildVaccination>>(args?: {
    where?: ChildVaccinationWhereInput;
    orderBy?: ChildVaccinationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChildSubscription
  extends Promise<AsyncIterator<Child>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parent: <T = UserSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  born: () => Promise<AsyncIterator<DateTimeOutput>>;
  vaccinations: <
    T = Promise<AsyncIterator<ChildVaccinationSubscription>>
  >(args?: {
    where?: ChildVaccinationWhereInput;
    orderBy?: ChildVaccinationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChildNullablePromise
  extends Promise<Child | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parent: <T = UserPromise>() => T;
  name: () => Promise<String>;
  born: () => Promise<DateTimeOutput>;
  vaccinations: <T = FragmentableArray<ChildVaccination>>(args?: {
    where?: ChildVaccinationWhereInput;
    orderBy?: ChildVaccinationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  vaccinations: <T = FragmentableArray<UserVaccination>>(args?: {
    where?: UserVaccinationWhereInput;
    orderBy?: UserVaccinationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = FragmentableArray<Child>>(args?: {
    where?: ChildWhereInput;
    orderBy?: ChildOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  vaccinations: <
    T = Promise<AsyncIterator<UserVaccinationSubscription>>
  >(args?: {
    where?: UserVaccinationWhereInput;
    orderBy?: UserVaccinationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = Promise<AsyncIterator<ChildSubscription>>>(args?: {
    where?: ChildWhereInput;
    orderBy?: ChildOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  vaccinations: <T = FragmentableArray<UserVaccination>>(args?: {
    where?: UserVaccinationWhereInput;
    orderBy?: UserVaccinationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = FragmentableArray<Child>>(args?: {
    where?: ChildWhereInput;
    orderBy?: ChildOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserVaccination {
  id: ID_Output;
  createdAt: DateTimeOutput;
  takenAt?: DateTimeOutput;
  untilNext?: String;
  protectDuration?: String;
}

export interface UserVaccinationPromise
  extends Promise<UserVaccination>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  type: <T = VaccinationPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  takenAt: () => Promise<DateTimeOutput>;
  untilNext: () => Promise<String>;
  protectDuration: () => Promise<String>;
}

export interface UserVaccinationSubscription
  extends Promise<AsyncIterator<UserVaccination>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  type: <T = VaccinationSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  takenAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  untilNext: () => Promise<AsyncIterator<String>>;
  protectDuration: () => Promise<AsyncIterator<String>>;
}

export interface UserVaccinationNullablePromise
  extends Promise<UserVaccination | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  type: <T = VaccinationPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  takenAt: () => Promise<DateTimeOutput>;
  untilNext: () => Promise<String>;
  protectDuration: () => Promise<String>;
}

export interface Vaccination {
  id: ID_Output;
  name: String;
  dose?: Int;
  url: String;
  untilNext?: String;
  protectDuration?: String;
}

export interface VaccinationPromise extends Promise<Vaccination>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  dose: () => Promise<Int>;
  url: () => Promise<String>;
  untilNext: () => Promise<String>;
  protectDuration: () => Promise<String>;
}

export interface VaccinationSubscription
  extends Promise<AsyncIterator<Vaccination>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  dose: () => Promise<AsyncIterator<Int>>;
  url: () => Promise<AsyncIterator<String>>;
  untilNext: () => Promise<AsyncIterator<String>>;
  protectDuration: () => Promise<AsyncIterator<String>>;
}

export interface VaccinationNullablePromise
  extends Promise<Vaccination | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  dose: () => Promise<Int>;
  url: () => Promise<String>;
  untilNext: () => Promise<String>;
  protectDuration: () => Promise<String>;
}

export interface ChildVaccination {
  id: ID_Output;
  createdAt: DateTimeOutput;
  takenAt: DateTimeOutput;
  untilNext?: String;
  protectDuration?: String;
}

export interface ChildVaccinationPromise
  extends Promise<ChildVaccination>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  child: <T = ChildPromise>() => T;
  type: <T = VaccinationPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  takenAt: () => Promise<DateTimeOutput>;
  untilNext: () => Promise<String>;
  protectDuration: () => Promise<String>;
}

export interface ChildVaccinationSubscription
  extends Promise<AsyncIterator<ChildVaccination>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  child: <T = ChildSubscription>() => T;
  type: <T = VaccinationSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  takenAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  untilNext: () => Promise<AsyncIterator<String>>;
  protectDuration: () => Promise<AsyncIterator<String>>;
}

export interface ChildVaccinationNullablePromise
  extends Promise<ChildVaccination | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  child: <T = ChildPromise>() => T;
  type: <T = VaccinationPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  takenAt: () => Promise<DateTimeOutput>;
  untilNext: () => Promise<String>;
  protectDuration: () => Promise<String>;
}

export interface ChildConnection {
  pageInfo: PageInfo;
  edges: ChildEdge[];
}

export interface ChildConnectionPromise
  extends Promise<ChildConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChildEdge>>() => T;
  aggregate: <T = AggregateChildPromise>() => T;
}

export interface ChildConnectionSubscription
  extends Promise<AsyncIterator<ChildConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChildEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChildSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ChildEdge {
  node: Child;
  cursor: String;
}

export interface ChildEdgePromise extends Promise<ChildEdge>, Fragmentable {
  node: <T = ChildPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChildEdgeSubscription
  extends Promise<AsyncIterator<ChildEdge>>,
    Fragmentable {
  node: <T = ChildSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChild {
  count: Int;
}

export interface AggregateChildPromise
  extends Promise<AggregateChild>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChildSubscription
  extends Promise<AsyncIterator<AggregateChild>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChildVaccinationConnection {
  pageInfo: PageInfo;
  edges: ChildVaccinationEdge[];
}

export interface ChildVaccinationConnectionPromise
  extends Promise<ChildVaccinationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChildVaccinationEdge>>() => T;
  aggregate: <T = AggregateChildVaccinationPromise>() => T;
}

export interface ChildVaccinationConnectionSubscription
  extends Promise<AsyncIterator<ChildVaccinationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChildVaccinationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChildVaccinationSubscription>() => T;
}

export interface ChildVaccinationEdge {
  node: ChildVaccination;
  cursor: String;
}

export interface ChildVaccinationEdgePromise
  extends Promise<ChildVaccinationEdge>,
    Fragmentable {
  node: <T = ChildVaccinationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChildVaccinationEdgeSubscription
  extends Promise<AsyncIterator<ChildVaccinationEdge>>,
    Fragmentable {
  node: <T = ChildVaccinationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChildVaccination {
  count: Int;
}

export interface AggregateChildVaccinationPromise
  extends Promise<AggregateChildVaccination>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChildVaccinationSubscription
  extends Promise<AsyncIterator<AggregateChildVaccination>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserVaccinationConnection {
  pageInfo: PageInfo;
  edges: UserVaccinationEdge[];
}

export interface UserVaccinationConnectionPromise
  extends Promise<UserVaccinationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserVaccinationEdge>>() => T;
  aggregate: <T = AggregateUserVaccinationPromise>() => T;
}

export interface UserVaccinationConnectionSubscription
  extends Promise<AsyncIterator<UserVaccinationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserVaccinationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserVaccinationSubscription>() => T;
}

export interface UserVaccinationEdge {
  node: UserVaccination;
  cursor: String;
}

export interface UserVaccinationEdgePromise
  extends Promise<UserVaccinationEdge>,
    Fragmentable {
  node: <T = UserVaccinationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserVaccinationEdgeSubscription
  extends Promise<AsyncIterator<UserVaccinationEdge>>,
    Fragmentable {
  node: <T = UserVaccinationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserVaccination {
  count: Int;
}

export interface AggregateUserVaccinationPromise
  extends Promise<AggregateUserVaccination>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserVaccinationSubscription
  extends Promise<AsyncIterator<AggregateUserVaccination>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VaccinationConnection {
  pageInfo: PageInfo;
  edges: VaccinationEdge[];
}

export interface VaccinationConnectionPromise
  extends Promise<VaccinationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VaccinationEdge>>() => T;
  aggregate: <T = AggregateVaccinationPromise>() => T;
}

export interface VaccinationConnectionSubscription
  extends Promise<AsyncIterator<VaccinationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VaccinationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVaccinationSubscription>() => T;
}

export interface VaccinationEdge {
  node: Vaccination;
  cursor: String;
}

export interface VaccinationEdgePromise
  extends Promise<VaccinationEdge>,
    Fragmentable {
  node: <T = VaccinationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VaccinationEdgeSubscription
  extends Promise<AsyncIterator<VaccinationEdge>>,
    Fragmentable {
  node: <T = VaccinationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVaccination {
  count: Int;
}

export interface AggregateVaccinationPromise
  extends Promise<AggregateVaccination>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVaccinationSubscription
  extends Promise<AsyncIterator<AggregateVaccination>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ChildSubscriptionPayload {
  mutation: MutationType;
  node: Child;
  updatedFields: String[];
  previousValues: ChildPreviousValues;
}

export interface ChildSubscriptionPayloadPromise
  extends Promise<ChildSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChildPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChildPreviousValuesPromise>() => T;
}

export interface ChildSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChildSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChildSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChildPreviousValuesSubscription>() => T;
}

export interface ChildPreviousValues {
  id: ID_Output;
  name: String;
  born: DateTimeOutput;
}

export interface ChildPreviousValuesPromise
  extends Promise<ChildPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  born: () => Promise<DateTimeOutput>;
}

export interface ChildPreviousValuesSubscription
  extends Promise<AsyncIterator<ChildPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  born: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ChildVaccinationSubscriptionPayload {
  mutation: MutationType;
  node: ChildVaccination;
  updatedFields: String[];
  previousValues: ChildVaccinationPreviousValues;
}

export interface ChildVaccinationSubscriptionPayloadPromise
  extends Promise<ChildVaccinationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChildVaccinationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChildVaccinationPreviousValuesPromise>() => T;
}

export interface ChildVaccinationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChildVaccinationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChildVaccinationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChildVaccinationPreviousValuesSubscription>() => T;
}

export interface ChildVaccinationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  takenAt: DateTimeOutput;
  untilNext?: String;
  protectDuration?: String;
}

export interface ChildVaccinationPreviousValuesPromise
  extends Promise<ChildVaccinationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  takenAt: () => Promise<DateTimeOutput>;
  untilNext: () => Promise<String>;
  protectDuration: () => Promise<String>;
}

export interface ChildVaccinationPreviousValuesSubscription
  extends Promise<AsyncIterator<ChildVaccinationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  takenAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  untilNext: () => Promise<AsyncIterator<String>>;
  protectDuration: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface UserVaccinationSubscriptionPayload {
  mutation: MutationType;
  node: UserVaccination;
  updatedFields: String[];
  previousValues: UserVaccinationPreviousValues;
}

export interface UserVaccinationSubscriptionPayloadPromise
  extends Promise<UserVaccinationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserVaccinationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserVaccinationPreviousValuesPromise>() => T;
}

export interface UserVaccinationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserVaccinationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserVaccinationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserVaccinationPreviousValuesSubscription>() => T;
}

export interface UserVaccinationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  takenAt?: DateTimeOutput;
  untilNext?: String;
  protectDuration?: String;
}

export interface UserVaccinationPreviousValuesPromise
  extends Promise<UserVaccinationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  takenAt: () => Promise<DateTimeOutput>;
  untilNext: () => Promise<String>;
  protectDuration: () => Promise<String>;
}

export interface UserVaccinationPreviousValuesSubscription
  extends Promise<AsyncIterator<UserVaccinationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  takenAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  untilNext: () => Promise<AsyncIterator<String>>;
  protectDuration: () => Promise<AsyncIterator<String>>;
}

export interface VaccinationSubscriptionPayload {
  mutation: MutationType;
  node: Vaccination;
  updatedFields: String[];
  previousValues: VaccinationPreviousValues;
}

export interface VaccinationSubscriptionPayloadPromise
  extends Promise<VaccinationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VaccinationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VaccinationPreviousValuesPromise>() => T;
}

export interface VaccinationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VaccinationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VaccinationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VaccinationPreviousValuesSubscription>() => T;
}

export interface VaccinationPreviousValues {
  id: ID_Output;
  name: String;
  dose?: Int;
  url: String;
  untilNext?: String;
  protectDuration?: String;
}

export interface VaccinationPreviousValuesPromise
  extends Promise<VaccinationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  dose: () => Promise<Int>;
  url: () => Promise<String>;
  untilNext: () => Promise<String>;
  protectDuration: () => Promise<String>;
}

export interface VaccinationPreviousValuesSubscription
  extends Promise<AsyncIterator<VaccinationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  dose: () => Promise<AsyncIterator<Int>>;
  url: () => Promise<AsyncIterator<String>>;
  untilNext: () => Promise<AsyncIterator<String>>;
  protectDuration: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Vaccination",
    embedded: false
  },
  {
    name: "UserVaccination",
    embedded: false
  },
  {
    name: "Child",
    embedded: false
  },
  {
    name: "ChildVaccination",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
